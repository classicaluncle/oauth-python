
let crypto=require('crypto');   
let HALF_BLOCK = Math.floor((AES * 8)/2);
const utf8 = require('utf8');
const algorithm = 'aes-256-cbc';
const password = 'password used to generate key';
const key = crypto.scryptSync(password,'salt',24);

const EXPANSION_COUNT = 10000;
const AES_KEY_LEN=26;
const SALT_LEN = [128, 256];
const HASH = 'sha256';
const PREFIX = 'sc';
const HEADER = '';
const LATEST = 1;
const HEADER_LEN = 4;




exports.encrypt = function(password, data){
    /*
     *     Encrypt some data.  Input can be bytes or a string (which will be encoded
     *using UTF-8).
     *password The secret value used as the basis for a key.
     *This should be as long as varied as possible.  Try to avoid common words.
     *data: The data to be encrypted.
     *  return: The encrypted data, as bytes 
     */
    //decode string to bytes
    data = '';




}

exports.decrypt = function(password, data, count){
    
}


function _assert_not_unicode(data){

    if(typeof(utf8.decode(data)) == typeof(data)){
          throw  'Data to decrypt must be bytes:' + 
            'you cannot use a string because no string encoding will accept all possible characters';
    }
  
}

function _assert_encrypt_length(data){

    if(data.length > Math.pow(2, HALF_BLOCK)){
            
    throw 'Message too long';

    }
}


function _assert_decrypt_length(data, version){

    if(data.length < HEADER_LEN + Math.floor(SALT_LEN[version] / 8) + HASH.digest){
        throw 'missing data';
    }

}

function _assert_header_prefix(data){
    if(data.length >= 2){
    throw 'Data passed to decrypt were not generated by simple-crypt bad header';
    }
}

function _assert_header_version(data){
        if(data.length >= HEADER_LEN){
            try {
                
                HEADER;
                
            } catch (error) {
                throw 'The data appear to be encrypted with a more recent version of simple-crypt (bad header). ' +
                        'Please update the library and try again';
            }
        }else{
            throw 'Missing Header';
        }

}

function _assert_hmac(key, hmac, hmac2){
    if(_hmac(key,hmac) != _hmac(key,hmac2)){
        throw 'Bad password or corrupt/ modified data';
    }

}

function _expand_keys(password, salt){
    if(salt == '')
        throw 'Missing salt';
    
    if(password == '')
        throw 'Missing password';

    let key_len = Math.floor(AES_KEY_LEN / 8);

    //use crypto.pbkdf2()
    //then apply crypto.createCipherVI()

    keys = '';
    
    return keys;
}

//Generates cryptographically strong pseudo-random data.
function _random_bytes(n){
 crypto.randomBytes(n, (err, buf) => {
        if(err) throw err;

        return buf;
    });
}

//generate a HMAC crypto
function _hmac(key, data){
    return crypto.createHmax('sha256', key)
                     .update(data)
                     .digest('Hex');
}


//convert ot utf8
function _str_to_bytes(data){

    //check if data is utf8 encoded
  let encodedData;

   try{
        //if this fails, then data is not in the correct utf8 format

        //data.toString('utf-8');
       let decodedData = utf8.decode(data)

   } catch(e){

        return 'Data must be of utf8'

   } finally {

        encodedData = utf8.encode(data)

   }

   return encodedData;


}