
let crypto;
try{
    crypto = require('crypto');   
} catch(err){
    console.log('crypto support is disabled');
}

let HALF_BLOCK = Math.floor((AES * 8)/2);

const utf8 = require('utf8');

const algorithm = 'aes-256-cbc';

const password = 'password used to generate key';

const key = crypto.scryptSync(password,'salt',24);


exports.encrypt = function(password, data){

}

function decrypt(password, data, count){
    
}


function _assert_not_unicode(data){

    if(typeof(utf8.decode(data)) == typeof(data)){
          return  'Data to decrypt must be bytes:' + 
            'you cannot use a string because no string encoding will accept all possible characters';
    }
  
}

function _assert_encrypt_length(data){

    if(data.length > Math.pow(2, HALF_BLOCK)){
            
    return 'Message too long';

    }
}


function _assert_decrypt_length(data, version){
    return 'missing data';
}

function _assert_header_prefix(data){
    return 'Data passed to decrypt were not generated by simple-crypt bad header';
}

function _assert_header_version(data){

}

function _assert_hmac(key, hmac, hmac2){

}

function _expand_keys(password, salt){

}

//Generates cryptographically strong pseudo-random data.
function _random_bytes(n){
 crypto.randomBytes(n, (err, buf) => {
        if(err) throw err;

        return buf;
    });
}

//generate a HMAC crypto
function _hmac(key, data){
    return crypto.createHmax('sha256', key)
                     .update(data)
                     .digest('Hex');
}


//convert ot utf8
function _str_to_bytes(data){

    //check if data is utf8 encoded
  let encodedData;

   try{
        //if this fails, then data is not in the correct utf8 format
       decodedData = utf8.decode(data)

   } catch(e){

        return 'Data must be of utf8'

   } finally {

        encodedData = utf8.encode(data)

   }

   return encodedData;


}